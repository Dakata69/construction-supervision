# Генериране на документи (Word/PDF) - Детайлно обяснение

## Какво е генериране на документи?

Процесът, при който:
1. Взимаме **Word шаблон** с placeholders (`{{име на поле}}`)
2. Заменяме placeholders с **реални данни** от проект
3. Генерираме **готов Word документ**
4. Опционално: Преобразуваме към **PDF**

**Аналогия**: Като Mail Merge в Word - имаш писмо с `{{име}}` и го попълваш автоматично за всеки човек.

---

## Архитектура на системата за генериране

```
┌─────────────────────────────────────────────────────────────┐
│                         Frontend                            │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ 1. Потребител попълва форма (GenerateAct.tsx)        │  │
│  │    - Име на проект                                   │  │
│  │    - Дата на акт                                     │  │
│  │    - Участници (възложител, консултант, ...)        │  │
│  └──────────────────────┬───────────────────────────────┘  │
│                         │ POST /api/documents/generate/    │
│                         │ Body: {template_name, context}   │
└─────────────────────────┼───────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│                         Backend                             │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ 2. DocumentViewSet.generate_document()               │  │
│  │    - Валидира данните                                │  │
│  │    - Извиква document_generator.py                   │  │
│  └──────────────────────┬───────────────────────────────┘  │
│                         │                                   │
│                         ▼                                   │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ 3. generate_document_from_template()                 │  │
│  │    - Отваря Word шаблон                              │  │
│  │    - Заменя {{placeholders}} с данни                 │  │
│  │    - Премахва незапълнени placeholders               │  │
│  │    - Запазва нов .docx файл                          │  │
│  └──────────────────────┬───────────────────────────────┘  │
│                         │                                   │
│                         ▼                                   │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ 4. export_to_pdf() (опционално)                     │  │
│  │    - Използва LibreOffice/unoconv                    │  │
│  │    - Конвертира .docx → .pdf                         │  │
│  └──────────────────────┬───────────────────────────────┘  │
│                         │                                   │
│                         ▼                                   │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ 5. Връща URLs към генерираните файлове               │  │
│  │    - docx_url: /media/generated/act14_2025...docx    │  │
│  │    - pdf_url: /media/generated/act14_2025...pdf      │  │
│  └──────────────────────┬───────────────────────────────┘  │
└─────────────────────────┼───────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│                         Frontend                            │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ 6. Получава URLs и отваря документите                │  │
│  │    - window.open(docx_url) → Download Word файл      │  │
│  │    - window.open(pdf_url) → Преглед на PDF           │  │
│  └──────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

---

## Шаблони за документи

Шаблоните са Word файлове (.docx) с **placeholders**.

### Структура на placeholder:

```
{{име_на_поле}}
```

**Примери:**
```
{{project_name}}        → Име на проект
{{act_date}}            → Дата на акт
{{act_number}}          → Номер на акт
{{client_name}}         → Възложител
{{consultant_name}}     → Консултант
{{designer_name}}       → Проектант
{{contractor_name}}     → Изпълнител
```

### Пример шаблон (act14_bg.docx):

```
═══════════════════════════════════════════════════════════
                         АКТ № 14
═══════════════════════════════════════════════════════════

за установяване годността за приемане на строежа

Номер: {{act_number}}
Дата: {{act_date}}

1. ОБЕКТ НА СТРОИТЕЛСТВОТО

Наименование: {{project_name}}
Местонахождение: {{location}}

2. УЧАСТНИЦИ

Възложител: {{client_name}}
Строителен надзор: {{consultant_name}}
Проектант: {{designer_name}}
Изпълнител: {{contractor_name}}

3. УСТАНОВЯВАНЕ

Комисията установи, че строежът е изпълнен съгласно 
одобрените инвестиционни проекти и строителните книжа.

ДАТА: {{act_date}}

ПОДПИСИ:

Възложител: ___________________ ({{client_name}})
Строителен надзор: ___________________ ({{consultant_name}})
Проектант: ___________________ ({{designer_name}})
Изпълнител: ___________________ ({{contractor_name}})
```

### Местоположение на шаблони:

```
backend/media/templates/
├── act7_bg.docx         ← Акт 7
├── act14_bg.docx        ← Акт 14
└── act15_bg.docx        ← Акт 15
```

---

## Код обяснение (стъпка по стъпка)

### 1. Frontend - Форма за генериране (GenerateAct.tsx)

```tsx
import { useState } from 'react';
import { Form, Input, Button, Select, DatePicker, message, Card } from 'antd';
import { FileWordOutlined } from '@ant-design/icons';
import api from '../api/client';

function GenerateAct() {
  const [loading, setLoading] = useState(false);
  const [form] = Form.useForm();
  
  // СТЪПКА 1: Обработка на submit
  const handleSubmit = async (values: any) => {
    setLoading(true);
    
    try {
      // СТЪПКА 2: Подготовка на context данни
      const context = {
        // Основна информация
        project_name: values.project_name,
        location: values.location,
        
        // Акт данни
        act_number: values.act_number,
        act_date: values.act_date.format('DD.MM.YYYY'),  // Ant Design DatePicker връща moment object
        
        // Участници
        client_name: values.client_name,
        consultant_name: values.consultant_name,
        designer_name: values.designer_name,
        contractor_name: values.contractor_name,
        
        // Допълнителни полета (специфични за различни актове)
        description: values.description || '',
        notes: values.notes || '',
      };
      
      // СТЪПКА 3: Изпращане към backend
      const response = await api.post('/documents/generate/', {
        template_name: 'act14_bg.docx',  // Кой шаблон да използва
        context: context,                // Данни за попълване
      });
      
      // СТЪПКА 4: Успешен резултат
      message.success('Акт 14 е генериран успешно!');
      
      // СТЪПКА 5: Download на Word файла
      if (response.data.docx_url) {
        // Отваря URL в нов таб → браузърът download-ва файла
        window.open(`http://localhost:8000${response.data.docx_url}`, '_blank');
      }
      
      // СТЪПКА 6: (Опционално) Download на PDF
      if (response.data.pdf_url) {
        setTimeout(() => {
          window.open(`http://localhost:8000${response.data.pdf_url}`, '_blank');
        }, 500);  // 500ms забавяне
      }
      
      // СТЪПКА 7: Reset формата
      form.resetFields();
      
    } catch (error: any) {
      // Грешка при генериране
      const errorMessage = error.response?.data?.message || 'Грешка при генериране на документ';
      message.error(errorMessage);
      console.error('Generate error:', error);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <Card title="Генериране на Акт 14" extra={<FileWordOutlined />}>
      <Form
        form={form}
        layout="vertical"
        onFinish={handleSubmit}
      >
        {/* Основна информация */}
        <Form.Item
          label="Име на проект"
          name="project_name"
          rules={[{ required: true, message: 'Въведете име на проект' }]}
        >
          <Input placeholder="Жилищна сграда в гр. София" />
        </Form.Item>
        
        <Form.Item
          label="Местонахождение"
          name="location"
          rules={[{ required: true, message: 'Въведете местонахождение' }]}
        >
          <Input placeholder="гр. София, ул. Витоша 1" />
        </Form.Item>
        
        {/* Акт данни */}
        <Form.Item
          label="Номер на акт"
          name="act_number"
          rules={[{ required: true, message: 'Въведете номер на акт' }]}
        >
          <Input placeholder="14-2025-001" />
        </Form.Item>
        
        <Form.Item
          label="Дата на акт"
          name="act_date"
          rules={[{ required: true, message: 'Изберете дата' }]}
        >
          <DatePicker 
            format="DD.MM.YYYY" 
            style={{ width: '100%' }}
            placeholder="Изберете дата"
          />
        </Form.Item>
        
        {/* Участници */}
        <Form.Item
          label="Възложител"
          name="client_name"
          rules={[{ required: true, message: 'Въведете възложител' }]}
        >
          <Input placeholder="Строй ЕООД" />
        </Form.Item>
        
        <Form.Item
          label="Строителен надзор (консултант)"
          name="consultant_name"
          rules={[{ required: true, message: 'Въведете консултант' }]}
        >
          <Input placeholder="Инж. Иван Иванов" />
        </Form.Item>
        
        <Form.Item
          label="Проектант"
          name="designer_name"
          rules={[{ required: true, message: 'Въведете проектант' }]}
        >
          <Input placeholder="Арх. Петър Петров" />
        </Form.Item>
        
        <Form.Item
          label="Изпълнител"
          name="contractor_name"
          rules={[{ required: true, message: 'Въведете изпълнител' }]}
        >
          <Input placeholder="Билдинг ООД" />
        </Form.Item>
        
        {/* Описание (опционално) */}
        <Form.Item
          label="Описание"
          name="description"
        >
          <Input.TextArea 
            rows={4} 
            placeholder="Допълнителна информация за строежа"
          />
        </Form.Item>
        
        {/* Submit button */}
        <Form.Item>
          <Button 
            type="primary" 
            htmlType="submit" 
            loading={loading}
            icon={<FileWordOutlined />}
            block
            size="large"
          >
            {loading ? 'Генериране...' : 'Генерирай Акт 14'}
          </Button>
        </Form.Item>
      </Form>
    </Card>
  );
}

export default GenerateAct;
```

**Какво се случва при submit:**

```
1. Потребител попълва формата
2. Кликва "Генерирай Акт 14"
3. Ant Design Form валидира всички полета (required rules)
4. Извиква handleSubmit(values)
5. values = { project_name: "X", act_date: moment(...), ... }
6. Форматира act_date към "DD.MM.YYYY"
7. Създава context обект
8. Изпраща POST заявка към /api/documents/generate/
9. Backend обработва и връща URLs
10. Отваря URLs в нови табове (download)
11. Reset-ва формата
```

---

### 2. Backend - API Endpoint (views/document.py)

```python
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from core.utils.document_generator import generate_document_from_template
from core.utils.pdf_export import export_to_pdf
from django.conf import settings
import os

class DocumentViewSet(viewsets.ViewSet):
    permission_classes = [IsAuthenticated]
    
    @action(detail=False, methods=['post'])
    def generate(self, request):
        """
        API endpoint за генериране на документи
        POST /api/documents/generate/
        
        Body:
        {
            "template_name": "act14_bg.docx",
            "context": {
                "project_name": "Жилищна сграда",
                "act_date": "28.11.2025",
                ...
            }
        }
        """
        
        # СТЪПКА 1: Валидация на входни данни
        template_name = request.data.get('template_name')
        context = request.data.get('context', {})
        
        if not template_name:
            return Response(
                {'error': 'Липсва template_name'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        if not context:
            return Response(
                {'error': 'Липсва context'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            # СТЪПКА 2: Генериране на Word документ
            docx_path = generate_document_from_template(
                template_name=template_name,
                context=context
            )
            
            # СТЪПКА 3: Генериране на PDF (опционално)
            pdf_path = None
            if request.data.get('generate_pdf', True):  # По подразбиране True
                pdf_path = export_to_pdf(docx_path)
            
            # СТЪПКА 4: Подготовка на URLs
            # docx_path = /full/path/backend/media/generated/act14_20251128_153000.docx
            # Трябва да го направим относителен URL
            
            # Вземи пътя спрямо MEDIA_ROOT
            relative_docx = os.path.relpath(docx_path, settings.MEDIA_ROOT)
            docx_url = f'/media/{relative_docx}'.replace('\\', '/')  # Windows fix
            
            response_data = {
                'success': True,
                'message': 'Документът е генериран успешно',
                'docx_url': docx_url,  # /media/generated/act14_20251128_153000.docx
            }
            
            if pdf_path:
                relative_pdf = os.path.relpath(pdf_path, settings.MEDIA_ROOT)
                pdf_url = f'/media/{relative_pdf}'.replace('\\', '/')
                response_data['pdf_url'] = pdf_url
            
            # СТЪПКА 5: Връщане на отговор
            return Response(response_data, status=status.HTTP_201_CREATED)
            
        except FileNotFoundError as e:
            # Шаблонът не е намерен
            return Response(
                {'error': f'Шаблонът не е намерен: {str(e)}'},
                status=status.HTTP_404_NOT_FOUND
            )
        
        except Exception as e:
            # Друга грешка
            import traceback
            print(traceback.format_exc())  # Log на грешката
            
            return Response(
                {'error': f'Грешка при генериране: {str(e)}'},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
```

---

### 3. Document Generator - Ядрото на генерирането (utils/document_generator.py)

```python
import os
import re
from datetime import datetime
from docx import Document
from django.conf import settings

def generate_document_from_template(template_name, context):
    """
    Генерира Word документ от шаблон
    
    Args:
        template_name (str): Име на шаблон файл (напр. 'act14_bg.docx')
        context (dict): Речник с данни за попълване
                       {'project_name': 'X', 'act_date': 'Y', ...}
    
    Returns:
        str: Абсолютен път до генерирания .docx файл
    
    Raises:
        FileNotFoundError: Ако шаблонът не съществува
    """
    
    # ═══════════════════════════════════════════════════════════════════
    # СТЪПКА 1: Намиране на шаблона
    # ═══════════════════════════════════════════════════════════════════
    
    template_path = os.path.join(
        settings.MEDIA_ROOT,  # backend/media/
        'templates',          # templates/
        template_name         # act14_bg.docx
    )
    # Резултат: backend/media/templates/act14_bg.docx
    
    # Провери дали файлът съществува
    if not os.path.exists(template_path):
        raise FileNotFoundError(f"Шаблонът '{template_name}' не е намерен в {template_path}")
    
    print(f"[1] Зареждане на шаблон: {template_path}")
    
    # ═══════════════════════════════════════════════════════════════════
    # СТЪПКА 2: Отваряне на шаблона с python-docx
    # ═══════════════════════════════════════════════════════════════════
    
    doc = Document(template_path)
    print(f"[2] Шаблонът е зареден. Параграфи: {len(doc.paragraphs)}, Таблици: {len(doc.tables)}")
    
    # ═══════════════════════════════════════════════════════════════════
    # СТЪПКА 3: Bidirectional mapping (за съвместимост)
    # ═══════════════════════════════════════════════════════════════════
    
    # Някои полета имат алтернативни имена в различни шаблони
    # Осигуряваме че ако подадат 'consultant_name', да работи и 'representative_supervision'
    
    field_mappings = {
        'consultant_name': 'representative_supervision',
        'designer_name': 'representative_designer',
        'contractor_name': 'representative_builder',
        'client_name': 'representative_client',
    }
    
    # Копирай данните с алтернативни имена
    for source_field, target_field in field_mappings.items():
        if source_field in context and target_field not in context:
            context[target_field] = context[source_field]
        elif target_field in context and source_field not in context:
            context[source_field] = context[target_field]
    
    print(f"[3] Context полета: {list(context.keys())}")
    
    # ═══════════════════════════════════════════════════════════════════
    # СТЪПКА 4: Замяна на placeholders в параграфи
    # ═══════════════════════════════════════════════════════════════════
    
    replaced_count = 0
    
    for paragraph in doc.paragraphs:
        original_text = paragraph.text
        
        # Провери дали има placeholders
        if '{{' in original_text and '}}' in original_text:
            new_text = original_text
            
            # Замени всеки placeholder
            for key, value in context.items():
                placeholder = f'{{{{{key}}}}}'  # {{key}}
                
                if placeholder in new_text:
                    # Замени с реална стойност
                    new_text = new_text.replace(placeholder, str(value))
                    replaced_count += 1
            
            # Обнови текста на параграфа
            paragraph.text = new_text
    
    print(f"[4] Заменени {replaced_count} placeholders в параграфи")
    
    # ═══════════════════════════════════════════════════════════════════
    # СТЪПКА 5: Замяна на placeholders в таблици
    # ═══════════════════════════════════════════════════════════════════
    
    table_replaced = 0
    
    for table in doc.tables:
        for row in table.rows:
            for cell in row.cells:
                original_text = cell.text
                
                if '{{' in original_text and '}}' in original_text:
                    new_text = original_text
                    
                    for key, value in context.items():
                        placeholder = f'{{{{{key}}}}}'
                        
                        if placeholder in new_text:
                            new_text = new_text.replace(placeholder, str(value))
                            table_replaced += 1
                    
                    cell.text = new_text
    
    print(f"[5] Заменени {table_replaced} placeholders в таблици")
    
    # ═══════════════════════════════════════════════════════════════════
    # СТЪПКА 6: Премахване на незапълнени placeholders
    # ═══════════════════════════════════════════════════════════════════
    
    # Regex pattern за {{anything}}
    placeholder_pattern = r'\{\{[^}]+\}\}'
    
    # Премахни от параграфи
    for paragraph in doc.paragraphs:
        if '{{' in paragraph.text:
            paragraph.text = re.sub(placeholder_pattern, '', paragraph.text)
    
    # Премахни от таблици
    for table in doc.tables:
        for row in table.rows:
            for cell in row.cells:
                if '{{' in cell.text:
                    cell.text = re.sub(placeholder_pattern, '', cell.text)
    
    print(f"[6] Премахнати незапълнени placeholders")
    
    # ═══════════════════════════════════════════════════════════════════
    # СТЪПКА 7: Генериране на уникално име за файла
    # ═══════════════════════════════════════════════════════════════════
    
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    # Пример: 20251128_153045
    
    # Премахни .docx от template_name и добави timestamp
    base_name = template_name.replace('.docx', '')
    filename = f"{base_name}_{timestamp}.docx"
    # Пример: act14_bg_20251128_153045.docx
    
    print(f"[7] Генерирано име: {filename}")
    
    # ═══════════════════════════════════════════════════════════════════
    # СТЪПКА 8: Запазване на документа
    # ═══════════════════════════════════════════════════════════════════
    
    output_dir = os.path.join(settings.MEDIA_ROOT, 'generated')
    # backend/media/generated/
    
    # Създай папка ако не съществува
    os.makedirs(output_dir, exist_ok=True)
    
    output_path = os.path.join(output_dir, filename)
    # backend/media/generated/act14_bg_20251128_153045.docx
    
    # Запази документа
    doc.save(output_path)
    
    print(f"[8] Документ запазен: {output_path}")
    
    # ═══════════════════════════════════════════════════════════════════
    # СТЪПКА 9: Връщане на пътя
    # ═══════════════════════════════════════════════════════════════════
    
    return output_path
```

**Визуализация на процеса:**

```
Шаблон (act14_bg.docx):
┌────────────────────────────────────────────┐
│ АКТ № 14                                   │
│ Номер: {{act_number}}                      │
│ Дата: {{act_date}}                         │
│                                            │
│ Проект: {{project_name}}                   │
│ Местонахождение: {{location}}              │
│                                            │
│ Възложител: {{client_name}}                │
│ Консултант: {{consultant_name}}            │
│ Проектант: {{designer_name}}               │
│ Изпълнител: {{contractor_name}}            │
└────────────────────────────────────────────┘

Context данни:
{
  "act_number": "14-2025-001",
  "act_date": "28.11.2025",
  "project_name": "Жилищна сграда",
  "location": "гр. София, ул. Витоша 1",
  "client_name": "Строй ЕООД",
  "consultant_name": "Инж. Иван Иванов",
  "designer_name": "Арх. Петър Петров",
  "contractor_name": "Билдинг ООД"
}

       ↓ generate_document_from_template() ↓

Генериран документ (act14_bg_20251128_153045.docx):
┌────────────────────────────────────────────┐
│ АКТ № 14                                   │
│ Номер: 14-2025-001                         │
│ Дата: 28.11.2025                           │
│                                            │
│ Проект: Жилищна сграда                     │
│ Местонахождение: гр. София, ул. Витоша 1  │
│                                            │
│ Възложител: Строй ЕООД                     │
│ Консултант: Инж. Иван Иванов               │
│ Проектант: Арх. Петър Петров               │
│ Изпълнител: Билдинг ООД                    │
└────────────────────────────────────────────┘
```

---

### 4. PDF Export (utils/pdf_export.py)

```python
import os
import subprocess
from django.conf import settings

def export_to_pdf(docx_path):
    """
    Конвертира .docx към .pdf използвайки LibreOffice
    
    Args:
        docx_path (str): Път до .docx файл
    
    Returns:
        str: Път до генерирания .pdf файл
    
    Raises:
        RuntimeError: Ако конверсията се провали
    """
    
    # СТЪПКА 1: Провери дали docx файлът съществува
    if not os.path.exists(docx_path):
        raise FileNotFoundError(f"Word файлът не е намерен: {docx_path}")
    
    # СТЪПКА 2: Подготви output path
    # docx_path = /path/to/act14_bg_20251128_153045.docx
    # pdf_path =  /path/to/act14_bg_20251128_153045.pdf
    pdf_path = docx_path.replace('.docx', '.pdf')
    
    # СТЪПКА 3: Намери output директория
    output_dir = os.path.dirname(docx_path)
    
    # СТЪПКА 4: Използвай LibreOffice за конверсия
    # LibreOffice има command-line инструмент за конверсия
    
    try:
        # Команда за конверсия
        # --headless = без GUI
        # --convert-to pdf = конвертирай към PDF
        # --outdir = къде да запази PDF-а
        command = [
            'libreoffice',
            '--headless',
            '--convert-to', 'pdf',
            '--outdir', output_dir,
            docx_path
        ]
        
        # Изпълни командата
        result = subprocess.run(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            timeout=30  # Timeout 30 секунди
        )
        
        # Провери дали е успешно
        if result.returncode != 0:
            error_message = result.stderr.decode('utf-8')
            raise RuntimeError(f"LibreOffice грешка: {error_message}")
        
        # Провери дали PDF-ът е създаден
        if not os.path.exists(pdf_path):
            raise RuntimeError("PDF файлът не е създаден")
        
        print(f"[PDF] Успешна конверсия: {pdf_path}")
        return pdf_path
        
    except subprocess.TimeoutExpired:
        raise RuntimeError("Timeout при конверсия към PDF (повече от 30 сек)")
    
    except FileNotFoundError:
        # LibreOffice не е инсталиран
        raise RuntimeError(
            "LibreOffice не е намерен. Моля инсталирайте го:\n"
            "Ubuntu: sudo apt-get install libreoffice\n"
            "Windows: Download from https://www.libreoffice.org/"
        )
```

**Забележка:** На Windows пътят към LibreOffice може да е различен:

```python
# Windows LibreOffice path
LIBREOFFICE_PATH = r'C:\Program Files\LibreOffice\program\soffice.exe'

command = [
    LIBREOFFICE_PATH,
    '--headless',
    '--convert-to', 'pdf',
    '--outdir', output_dir,
    docx_path
]
```

---

## Специални случаи и advanced техники

### 1. Форматиране на текст в placeholders

Понякога искаме да запазим форматирането (bold, italic, цвят).

**Проблем:** `paragraph.text = new_text` изтрива форматирането.

**Решение:** Работа с runs:

```python
def replace_placeholder_in_paragraph(paragraph, placeholder, value):
    """Замяна на placeholder със запазване на форматиране"""
    
    # Обедини всички runs в един текст
    full_text = ''.join(run.text for run in paragraph.runs)
    
    if placeholder in full_text:
        # Намери позицията на placeholder-а
        index = full_text.index(placeholder)
        
        # Изтрий всички runs
        for run in paragraph.runs:
            run.text = ''
        
        # Създай нов run с новия текст
        new_run = paragraph.runs[0] if paragraph.runs else paragraph.add_run()
        new_run.text = full_text.replace(placeholder, str(value))
```

### 2. Таблици с динамичен брой редове

Пример: Списък с етажи, които трябва да се добавят динамично.

```python
def add_rows_to_table(table, data_list):
    """
    Добавя редове в таблица
    
    Args:
        table: docx Table обект
        data_list: Списък с данни [{'floor': 1, 'area': 100}, ...]
    """
    
    # Вземи row template (последният ред)
    template_row = table.rows[-1]
    
    for data in data_list:
        # Копирай template row
        new_row = table.add_row()
        
        # Попълни клетките
        new_row.cells[0].text = str(data['floor'])
        new_row.cells[1].text = str(data['area'])
```

### 3. Вмъкване на изображения

```python
from docx.shared import Inches

def insert_image(doc, placeholder, image_path):
    """Замяна на placeholder с изображение"""
    
    for paragraph in doc.paragraphs:
        if placeholder in paragraph.text:
            # Изтрий текста
            paragraph.text = paragraph.text.replace(placeholder, '')
            
            # Добави изображение
            run = paragraph.add_run()
            run.add_picture(image_path, width=Inches(4))
```

### 4. Conditions (условно съдържание)

Понякога искаме да показваме/скриваме части от документа.

**Пример шаблон:**

```
{{if_has_basement}}
Сутерен: {{basement_area}} кв.м
{{endif_has_basement}}
```

**Код:**

```python
def process_conditionals(doc, context):
    """Обработва {{if_...}} блокове"""
    
    for paragraph in doc.paragraphs:
        text = paragraph.text
        
        # Намери {{if_X}} ... {{endif_X}} блокове
        import re
        pattern = r'\{\{if_(\w+)\}\}(.*?)\{\{endif_\1\}\}'
        
        matches = re.findall(pattern, text, re.DOTALL)
        
        for condition_field, content in matches:
            # Провери условието
            if context.get(condition_field):
                # Запази съдържанието (премахни if/endif tags)
                text = text.replace(f'{{{{if_{condition_field}}}}}', '')
                text = text.replace(f'{{{{endif_{condition_field}}}}}', '')
            else:
                # Премахни целия блок
                full_block = f'{{{{if_{condition_field}}}}}{content}{{{{endif_{condition_field}}}}}'
                text = text.replace(full_block, '')
        
        paragraph.text = text
```

---

## Тестване

### Unit Test за generate_document_from_template:

```python
import unittest
from core.utils.document_generator import generate_document_from_template
from docx import Document

class TestDocumentGenerator(unittest.TestCase):
    
    def test_generate_act14(self):
        """Тества генериране на Акт 14"""
        
        context = {
            'project_name': 'Test Project',
            'act_number': 'TEST-001',
            'act_date': '01.01.2025',
            'location': 'Test Location',
            'client_name': 'Test Client',
            'consultant_name': 'Test Consultant',
            'designer_name': 'Test Designer',
            'contractor_name': 'Test Contractor',
        }
        
        # Генерирай документ
        output_path = generate_document_from_template('act14_bg.docx', context)
        
        # Провери че файлът е създаден
        self.assertTrue(os.path.exists(output_path))
        
        # Провери съдържанието
        doc = Document(output_path)
        full_text = '\n'.join([p.text for p in doc.paragraphs])
        
        # Провери че placeholders са заменени
        self.assertIn('Test Project', full_text)
        self.assertIn('TEST-001', full_text)
        self.assertNotIn('{{project_name}}', full_text)  # Placeholder не трябва да съществува
        
        # Cleanup
        os.remove(output_path)
```

---

## Troubleshooting

### Проблем 1: Placeholder не се заменя

**Причина:** Word понякога разделя текста на няколко runs.

**Пример:**
```
Вместо: "{{project_name}}" в един run
Става:  "{{proj" + "ect_name}}" в два runs
```

**Решение:**

```python
def merge_runs_in_paragraph(paragraph):
    """Обединява всички runs в един"""
    full_text = ''.join(run.text for run in paragraph.runs)
    
    # Изтрий всички runs освен първия
    for run in paragraph.runs[1:]:
        run.text = ''
    
    # Запиши целия текст в първия run
    if paragraph.runs:
        paragraph.runs[0].text = full_text
```

### Проблем 2: Кирилица се чупи

**Причина:** Encoding проблеми.

**Решение:** Увери се че context стойностите са Unicode:

```python
# Лошо
context = {'name': b'\xd0\x98\xd0\xb2\xd0\xb0\xd0\xbd'}  # bytes

# Добре
context = {'name': 'Иван'}  # str (Unicode)
```

### Проблем 3: LibreOffice не работи

**Решение за Windows:**

```python
import platform

def get_libreoffice_path():
    """Намери LibreOffice path за различни OS"""
    if platform.system() == 'Windows':
        possible_paths = [
            r'C:\Program Files\LibreOffice\program\soffice.exe',
            r'C:\Program Files (x86)\LibreOffice\program\soffice.exe',
        ]
        for path in possible_paths:
            if os.path.exists(path):
                return path
    else:
        return 'libreoffice'  # Unix systems
    
    raise RuntimeError("LibreOffice not found")
```

---

## Оптимизации

### 1. Кеширане на шаблони

```python
from functools import lru_cache

@lru_cache(maxsize=10)
def load_template(template_name):
    """Кеширай зареждането на шаблони"""
    template_path = os.path.join(settings.MEDIA_ROOT, 'templates', template_name)
    return Document(template_path)
```

### 2. Async генериране (Celery)

За много големи документи:

```python
from celery import shared_task

@shared_task
def generate_document_async(template_name, context):
    """Асинхронно генериране с Celery"""
    return generate_document_from_template(template_name, context)
```

---

## Следваща стъпка

Вижте **[05_БАЗА_ДАННИ.md](./05_БАЗА_ДАННИ.md)** за детайлно обяснение на базата данни.
